---
title: " Vignette illustrating the use of MOFA on the CLL data"
author: "Britta Velten and Ricard Argelaguet"
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc: true
vignette: >
  %\VignetteIndexEntry{Example_CLL}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This vignette show how to use MOFA including initialization, training and down-stream analysis.
For illustration we use the CLL data which is used in the MOFA publication.

```{r}
library(MultiAssayExperiment)
library(MOFAtools)
```

# Step 1: Initialize MOFA object

## Load data and create MOFA object
Data is loaded into MOFA using the [MultiAssayExperiment](https://bioconductor.org/packages/release/bioc/html/MultiAssayExperiment.html) framework.

Starting from a list of matrices where features are rows and samples are columns this can be easily constructed as follows:
```{r}
# list containing matrices for the following views: mRNA, Methyaltion, Drug Response, Mutations
# samples are columns, features are rows
data("CLL_data")
sapply(CLL_data, dim)

# data frame containing covariates not included in the training: sex, diagnosis
data("CLL_covariates")
head(CLL_covariates)

# Create MultiAssayExperiment object 
mae_CLL <- MultiAssayExperiment(experiments = CLL_data, colData = CLL_covariates)
```

## Create MOFA object using MultiAssayExperiment
'createMOFAobject' initialized an untrained MOFA object.
```{r}
MOFAobject <- createMOFAobject(mae_CLL)
MOFAobject
```


# Step 2: Fit the MOFA model
Now we can run MOFA on the untrained MOFA object from the last step. 
This step requires some time and is not evaluates in this vignette, users need to specify the location of their MOFA python installation and a directory used by MOFA for intermediate and final outputs.

## Define options
### Define I/O options
Important paths to specify:
- mofaDir: directory of the MOFA package
- outFile: Output file for the model
```{r, eval=FALSE}
DirOptions <- list(
  "mofaDir" = "your_path_to_MOFA/MOFApackage/scGFA/MOFA",
  "outFile" = "path_to_output_directory"
)
```

### Define model options
The user can look in the documentation and the function 'getDefaultModelOpts' for the different options, but the default ones usually work well The most important thing the user has to define is the initial number of latent variables and the likelihood type (if not provided, the model tries to guess it from the data) 
```{r, eval=FALSE}
# TO-DO: check consistency with final model parameters
ModelOptions <- getDefaultModelOpts(MOFAobject)
ModelOptions
```

### Define training options
The user can look in the documentation and the function 'getDefaultTrainOpts' for the different options, but the default ones work fine. The most important thing the user has to define is the maximum number of iterations and whether/how to drop inactive latent factors while training.
```{r, eval=FALSE}
# TO-DO: check consistency with final model parameters
TrainOptions <- getDefaultTrainOpts()
TrainOptions
```

## Prepare MOFA
Internally, prepareMOFA performs a set of sanity checks, fills the TrainOpts and ModelOpts slots of the MOFAmodel object and it also creates a set of temporary files with the input matrices that will be loaded by the Python core implementation
```{r, eval=FALSE}
MOFAobject <- prepareMOFA(MOFAobject, 
                      DirOptions = DirOptions,
                      ModelOptions = ModelOptions,
                      TrainOptions = TrainOptions
)
```

## Run MOFA
This step can take some time and it decouples from the R package, it is recommended to run it from the Python-based module directly using the txt files as input generated by 'prepareMOFA' and then re-load the fitted model stored in the hdf5 object back into R.
```{r, eval=FALSE}
MOFAobject <- runMOFA(MOFAobject, DirOptions)
```

For illustration, we load the model used in the paper from the hdf5 file produced by MOFA
```{r}
filepath <- system.file("extdata", "model15.hdf5", package = "MOFAtools")
MOFAobject <- loadModel(filepath, MOFAobject)
MOFAobject
```

# Step 3: Analyse a trained MOFA model
After training, we can explore the results from MOFA. We recommend the following semi-automated pipeline to disentangel adn characterize the drivers of variation identified by MOFA:

For a first overview we recommend:
  (1) Calculation of variance explained by each factor in each view

Next, factor can be further characterized using:
  (2) Inspection of top weighted features in the active views
  (3) Feature set enrichemnt analysis in the active views (where set annotations are present, e.g. gene sets for mRNA views)
  (4) Ordination of samples by factors to reveal clusters and graadients in the sample space
  
## (1) Calculation of variance explained by each factor in each view
This is done by the 'calculateVarianceExplained' function. The resulting plot allows to get an overivew of wich factors are active in which view and see which factors are unique and which capture co-variation between several views. Factors are ordered by overall variance explained, i.e. the first factor explains most varaince across all views.

```{r}
r2 <- calculateVarianceExplained(MOFAobject)
```

## (2) Inspection of top weighted features in the active views
To see top features for a given view and factor we can use the 'showTopWeights' function, e.g. for the first two factors on the mutation or mRNA view:

```{r}
showTopWeights(MOFAobject, "Mutations", "1")
```

All weights on a factors in a view can be looked at using the 'showAllWeights' function. 
Labels are set based on the 'threshold' or 'manual' parameter. 
```{r}
showAllWeights(MOFAobject, view = "Mutations", factor = "1", threshold = 1)
```


To get an overview across all factors in a given view we can use the 'showWeightHeatmap' function. Using the threshold paramater features and factors with loadings bewlow this threshold can be removed.
```{r}
showWeightHeatmap(MOFAobject, "Mutations", show_colnames=F)
showWeightHeatmap(MOFAobject, "Mutations", threshold = 0.1)
```

To see the original data for the genes with top weights on a factor use 'showDataHeatmap'.
```{r}
showDataHeatmap(MOFAobject, view="mRNA", factor="1", nfeatures=30)
```

## (3) Feature set enrichemnt analysis in the active views
The characterisation of factors usually requires the inspection of the corresponding weights. However, looking at the loadings of single features can be challenging, and often the combination of signal from functionally related sets of features (i.e. gene ontologies) is required.

Here we implemented a function for feature set enrichment analysis method (FeatureSetEnrichmentAnalysis) derived from the [PCGSE package](https://cran.r-project.org/web/packages/PCGSE/index.html).

The input of this function is a MOFA trained model (MOFAmodel), the factors for which to perform feature set enrichment (a character vector), the feature sets (a binary matrix) and a set of options regarding how the analysis should be performed, see also documentation of 'FeatureSetEnrichmentAnalysis'

We illustrate the use of this function using the [reactome](http://reactome.org) annotations.
```{r}
# Load reactome annotations, binary matrix with feature sets in rows and feautres in columns
data("reactomeGS")

# perfrom enrichment analysis
fsea.out <- FeatureSetEnrichmentAnalysis(MOFAobject, "mRNA", reactomeGS, alpha = 0.01)
```

The next step is to visualise the results of the Gene Set Enrichment Analysis. There are two default plots:
(a) General Overview: Barplot with number of enriched gene sets per view
```{r}
Barplot_FeatureSetEnrichmentAnalysis(fsea.out, alpha=0.01)
```

(b) Factor-specific:
```{r}
interestingFactors <- c("4","5")
for (factor in interestingFactors) {
  lineplot <- LinePlot_FeatureSetEnrichmentAnalysis(fsea.out, factor, threshold=0.01, max.pathways=10)
  print(lineplot)
}
```


## (4) Ordination of samples by factors to reveal clusters and graadients in the sample space

Samples can be visualized along factors of interest using the 'scatterPlot' function.
```{r}
scatterPlot(MOFAobject, factors = c("1", "2"), color_by = "IGHV", shape_by = "trisomy12")
```

An overview of pair-wise sctterplots for all or a subset of factors is produced by the 'scatterPairs' function
```{r}
# TO-DO covariates, warnings?
scatterPairs(MOFAobject, factors = c("1", "2", "3", "4"))
```

A single factor can be visualised using the 'beeswarmPlot' function
```{r}
# TO-DO covariates
beeswarmPlot(MOFAobject, factors = "1")
```

## Customized analysis
For customized exploration of weights and factors, you can directly obtain the weights, factors or training data in matrix or data.frame format using the 'getWeights', 'getFactors' and 'getTrainData'. You can specify a subset of views or factors, you are interested in; by default, all views and factors are reported.
```{r}
MOFAweights <- getWeights(MOFAobject, as.data.frame = T)
head(MOFAweights)
```

```{r}
MOFAfactors <- getFactors(MOFAobject, as.data.frame = T, include_intercept = F)
head(MOFAfactors)
```

```{r}
MOFAdata <- getTrainData(MOFAobject, as.data.frame = T, views = "Mutations")
head(MOFAdata)
```


# Further functionalities

## Imputation of missing observations
With the 'imputeMissing' function all missing values are imputed based on the MOFA model. The imputed data is then stored in the MOFAobject and can be accessed via 'getImputedData'.
```{r}
MOFAobject <- imputeMissing(MOFAobject)
imputedDrugs <- getImputedData(MOFAobject, view="Drugs")
```

## Prediction of views
With the 'predict' function, full views can be predicted based on the MOFA model with all or a subset of factors
```{r}
predictedDrugs <- predict(MOFAobject, view="Drugs", factors="all")
```


## Clustering of samples based on latent factors
Samples can be clustered according to their values on some or all latent factors using the 'clusterSamples' function.
```{r}
# TO-DO: k-means
h <- clusterSamples(MOFAobject, "all")
h <- clusterSamples(MOFAobject, "1")
```
